function solution(m, n, puddles) {
  const MOD = 1000000007;
  const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));
  puddles.forEach(([c, r]) => dp[r][c] = -1);
  dp[1][1] = dp[1][1] === -1 ? 0 : 1;

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      if (i === 1 && j === 1) continue;

      if (dp[i][j] === -1) {
        dp[i][j] = 0;
      } else {
        const fromTop = i > 1 ? dp[i - 1][j] : 0;
        const fromLeft = j > 1 ? dp[i][j - 1] : 0;
        dp[i][j] = (fromTop + fromLeft) % MOD;
      }
    }
  }

  return dp[n][m];
}

// 이 문제를 푸는 아이디어 및 과정
// 1. 가장 중요한 아이디어는 dp[i][j]가 나타내는 것이 i행 j열에 위치한 좌표까지 도달할 수 있는 경로의 개수라는 것이다.
// 2. 문제에 제공된 입력 값으로 예를 들면, dp[1][2]는 1행 2열에 위치한 좌표까지 도달할 수 있는 경로의 개수를 나타내므로, 1이 된다.
// 3. 이제 이 dp 배열을 채워나가는 방법에 이전 좌표의 경로를 이용하는 것이다.
// 4. 예를 들어, dp[1][3]을 구한다고 하면, 왼쪽에서 오는 경로와, 위에서 오는 경로를 더해서 구하는 것이다.(오른쪽과 아래로만 움직일 수 있으므로)
// 5. 이런 과정을 반복하면 최종적으로 dp[3][4]에는 3행 4열에 위치한 좌표까지 도달할 수 있는 경로의 개수가 저장된다.
// 6. 웅덩이 제한이 있으므로, 웅덩이 좌표에는 처음에 -1을 넣어주어 반복문을 진행할때 구별할 수 있도록하고,
// 반복문에서 이 웅덩이를 만나면 0을 넣어주어 경로가 0이라는 것을 표시해준다.
////